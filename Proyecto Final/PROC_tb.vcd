$date
	Wed Nov 18 20:36:44 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$var wire 8 ! program_byte [7:0] $end
$var wire 4 " oprnd [3:0] $end
$var wire 4 # instr [3:0] $end
$var reg 1 $ clk $end
$var reg 12 % counter12bit [11:0] $end
$var reg 1 & enCounter $end
$var reg 1 ' enFetch $end
$var reg 1 ( load $end
$var reg 1 ) reset $end
$scope module U1 $end
$var wire 1 $ clk $end
$var wire 12 * counter12bit [11:0] $end
$var wire 1 + enAccu $end
$var wire 1 , enBuf1 $end
$var wire 1 - enBuf2 $end
$var wire 1 & enCounter $end
$var wire 1 ' enFetch $end
$var wire 1 ( load $end
$var wire 1 ) reset $end
$var wire 8 . program_byte [7:0] $end
$var wire 4 / oprnd [3:0] $end
$var wire 4 0 instr [3:0] $end
$var wire 1 1 data_bus $end
$var wire 1 2 busOutput $end
$var wire 1 3 aluResult $end
$var wire 1 4 accu $end
$var wire 1 5 Z $end
$var wire 12 6 PC [11:0] $end
$var wire 1 7 C $end
$scope module U1 $end
$var wire 1 $ clk $end
$var wire 1 & enabled $end
$var wire 1 ( load $end
$var wire 12 8 load_Data [11:0] $end
$var wire 1 ) reset $end
$var reg 12 9 out_Val [11:0] $end
$upscope $end
$scope module U2 $end
$var wire 12 : address [11:0] $end
$var wire 8 ; data [7:0] $end
$upscope $end
$scope module U3 $end
$var wire 8 < En [7:0] $end
$var wire 1 $ clk $end
$var wire 1 ' enabled $end
$var wire 1 ) reset $end
$var reg 8 = Ou [7:0] $end
$upscope $end
$scope module U4 $end
$var wire 4 > A [3:0] $end
$var wire 1 , enabled $end
$var wire 4 ? Y [3:0] $end
$upscope $end
$scope module U5 $end
$var wire 4 @ A [3:0] $end
$var wire 1 - enabled $end
$var wire 4 A Y [3:0] $end
$upscope $end
$scope module U6 $end
$var wire 4 B A [3:0] $end
$var wire 4 C B [3:0] $end
$var wire 3 D F [2:0] $end
$var wire 1 5 Z $end
$var wire 4 E S [3:0] $end
$var wire 1 7 C $end
$var reg 5 F regS [4:0] $end
$upscope $end
$scope module U7 $end
$var wire 4 G D [3:0] $end
$var wire 1 $ clk $end
$var wire 1 + enabled $end
$var wire 1 ) reset $end
$var reg 4 H Q [3:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx H
b1 G
b10101 F
b101 E
b0z D
b0z C
b0x B
bx A
b1 @
bxz ?
b0z >
bx =
bx <
bx ;
bx :
bx 9
b0 8
17
bx 6
05
x4
13
x2
z1
bx 0
bx /
bx .
z-
z,
z+
b0 *
0)
0(
0'
0&
b0 %
0$
bx #
bx "
bx !
$end
#2
b0 "
b0 /
b0 #
b0 0
b0 B
04
b11110101 !
b11110101 .
b11110101 ;
b11110101 <
b0 6
b0 9
b0 :
b0 =
b0 H
1)
#3
1&
0)
#5
b1101010 !
b1101010 .
b1101010 ;
b1101010 <
b1 6
b1 9
b1 :
1$
#10
0$
#15
b1111 !
b1111 .
b1111 ;
b1111 <
b10 6
b10 9
b10 :
1$
#20
0$
#23
1(
b100100011 %
b100100011 *
b100100011 8
#25
b10010110 !
b10010110 .
b10010110 ;
b10010110 <
b100100011 6
b100100011 9
b100100011 :
1$
#30
0$
#33
b1010 %
b1010 *
b1010 8
0(
#35
b1101001 !
b1101001 .
b1101001 ;
b1101001 <
b100100100 6
b100100100 9
b100100100 :
1$
#40
0$
#43
1'
0&
#45
b1001 "
b1001 /
b110 #
b110 0
b1101001 =
1$
#50
0$
#55
1$
#60
0$
#65
1$
#70
0$
#75
1$
#80
0$
#85
1$
#90
0$
#95
1$
#100
0$
